# -*- coding: utf-8 -*-
"""cs170 project1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NTStqRlRgx4wimnl1piMkWPea1mA9NC0
"""

import math
import numpy as np
import copy
from math import sqrt
import re
import time

class Node:
  def __init__(self, state, parent, operator, cost, misplaced, euclideanDistance) :
    self.state = state
    self.parent = parent
    self.operator = operator
    self.cost = cost
    self.misplacedCost = misplaced
    self.euclideanDistanceCost = euclideanDistance

class FrontierUniform:
  def __init__(self):
    self.nodeList = []

  def add(self, node):
    self.nodeList.append(node)

  def addList(self, listNodes):
    for i in listNodes:
      self.nodeList.append(i)

  def popLeastCost(self):
    #print("DEBUG: now in popLeastCost")
    if len(self.nodeList) == 0:
      raise Exception("Error - popLeastCost has no node to return!")
    lowestCost = self.nodeList[0].cost
    lowestCostNode = self.nodeList[0]
    for i in self.nodeList:
      if i.cost < lowestCost:
        lowestCost = i.cost
        lowestCostNode = i
    self.nodeList.remove(lowestCostNode)
    print("Popping off the node with the least cost of g(n) = ",lowestCostNode.cost ,", which is:\n",np.matrix(lowestCostNode.state))
    return(lowestCostNode)

  def retLength(self):
    return len(self.nodeList)

  def printFrontier(self):
    ## print frontier
    if self.retLength() == 0:
      print("Frontier = empty")
    else:
      print("Frontier =")
      for i in range(0, self.retLength()):
        print(np.matrix(self.nodeList[i].state)) # print each frontier state (matrix)

class FrontierMisplaced:
  def __init__(self):
    self.nodeList = []

  def add(self, node):
    self.nodeList.append(node)

  def addList(self, listNodes):
    for i in listNodes:
      self.nodeList.append(i)

  def popLeastCost(self):
    #print("DEBUG: now in popLeastCost")
    if len(self.nodeList) == 0:
      raise Exception("Error - popLeastCost has no node to return!")
    lowestCost = self.nodeList[0].misplacedCost + self.nodeList[0].cost
    lowestCostNode = self.nodeList[0]
    for i in self.nodeList:
      if (i.misplacedCost + i.cost) < lowestCost:
        lowestCost = i.misplacedCost + i.cost
        lowestCostNode = i
    self.nodeList.remove(lowestCostNode)
    print("Popping off the node with the least cost of g(n) = ",lowestCostNode.cost," and h(n) = ", lowestCostNode.misplacedCost, "which is:\n",np.matrix(lowestCostNode.state))
    return(lowestCostNode)

  def retLength(self):
    return len(self.nodeList)

  def printFrontier(self):
    ## print frontier
    if self.retLength() == 0:
      print("Frontier = empty")
    else:
      print("Frontier =")
      for i in range(0, self.retLength()):
        print(np.matrix(self.nodeList[i].state)) # print each frontier state (matrix)

class Frontiereuclid:
  def __init__(self):
    self.nodeList = []

  def add(self, node):
    self.nodeList.append(node)

  def addList(self, listNodes):
    for i in listNodes:
      self.nodeList.append(i)

  def popLeastCost(self):
    #print("DEBUG: now in popLeastCost")
    if len(self.nodeList) == 0:
      raise Exception("Error - popLeastCost has no node to return!")
    lowestCost = self.nodeList[0].euclideanDistanceCost + self.nodeList[0].cost
    lowestCostNode = self.nodeList[0]
    for i in self.nodeList:
      if (i.euclideanDistanceCost + i.cost) < lowestCost:
        lowestCost = i.euclideanDistanceCost + i.cost
        lowestCostNode = i
    self.nodeList.remove(lowestCostNode)
    print("Popping off the node with the least cost of g(n)= ", lowestCostNode.cost,"h(n) = ",lowestCostNode.euclideanDistanceCost ," , which is:\n",np.matrix(lowestCostNode.state))
    return(lowestCostNode)

  def retLength(self):
    return len(self.nodeList)

  def printFrontier(self):
    ## print frontier
    if self.retLength() == 0:
      print("Frontier = empty")
    else:
      print("Frontier =")
      for i in range(0, self.retLength()):
        print(np.matrix(self.nodeList[i].state)) # print each frontier state (matrix)


class Problem:
  def __init__(self, startState, operators) :
    self.startState = startState
    self.operators = operators
    self.goalState = []
    self.stack = []

    ## Creating the goalstate
    for i in range(0, len(self.startState)):
      self.goalState.append([]) # add each row to the solution
    for i in (range(0, len(self.startState)**2)):
      if i != len(self.startState)**2 - 1:
        self.goalState[math.floor(i/len(self.startState))].append(i+1) # appends values row by row (row determined by rounding down division)
      else:
        self.goalState[math.floor(i/len(self.startState))].append(0)
    print("START: start state = \n", np.matrix(self.startState), "\n goal state = \n", np.matrix(self.goalState), "\n operators =", self.operators,"\n")


  def outputStack(self, stack):
    ## print stack
    if len(stack) == 0:
      print("Stack = empty")
    else:
      print("Stack =")
      for i in range(0, len(self.stack)):
        print(np.matrix(self.stack[i].state)) # print each stack state (matrix)
    print("")


  def solveUniformCostSearch(self):
    frontier = FrontierUniform()
    start = Node(state=self.startState, parent=None, operator=None, cost=0, misplaced=0, euclideanDistance=0) # create the start node for the problem
    maxNodes = 0
    ## 1) Push the node to the frontier (initial start)
    frontier.add(start)
    print("Start of search: size of frontier is", frontier.retLength()) # print the size of the frontier
    """
    self.outputStack(self.stack)
    frontier.printFrontier()
    print("")
    """

    # add loop here
    ## 2) See if the frontier is empty
    while frontier.retLength() > 0:
      """
      self.outputStack(self.stack)
      frontier.printFrontier()
      print("")
      """
      if frontier.retLength() == 0:
        print("Frontier is empty - No Solution!")
        return

      ## 3) Pop off the node from frontier
      if frontier.retLength() > maxNodes:
        maxNodes = frontier.retLength()
      currNode = frontier.popLeastCost()

      ## 4) Check if the node is a repeat - skip it, else add it to the stack
      self.stack.append(np.stack(currNode.state))

      ## 5) Check if the node is the goal state
      if np.array_equal(currNode.state, self.goalState):
        print("Goal state found!\n",np.matrix(currNode.state))
        print("number of nodes explored: ", len(self.stack))
        print("The depth of the goal node is: ", currNode.cost)
        print("The most nodes in the frontier during the search was: ", maxNodes)
        return

      ## 6) If not, create the children and add them to the frontier - also add the current node to stack
      neighbors = self.findNeighbors(currNode)

      for i in range(len(neighbors)):
        foundInStack = False
        for j in range(len(self.stack)):
          if (np.array_equal(neighbors[i].state, self.stack[j])):
            foundInStack = True
        if not(foundInStack) :
          frontier.add(neighbors[i])


      # Loop back
    print("Frontier end found with nothing - No Solution!")

    return


  def solveAStarMisplaced(self):
    frontier = FrontierMisplaced()
    start = Node(state=self.startState, parent=None, operator=None, cost=0, misplaced=0, euclideanDistance=0) # create the start node for the problem
    start.misplacedCost = self.calcMisplacedTiles(start)
    maxNodes = 0
    ## 1) Push the node to the frontier (initial start)
    frontier.add(start)
    print("Start of search: size of frontier is", frontier.retLength()) # print the size of the frontier

    ## 2) See if the frontier is empty
    while frontier.retLength() > 0:
      if frontier.retLength() == 0:
        print("Frontier is empty - No Solution!")
        return

    ## 3) Pop off the node from frontier
      if frontier.retLength() > maxNodes:
        maxNodes = frontier.retLength()
      currNode = frontier.popLeastCost()

    ## 4) Check if the node is a repeat - skip it, else add it to the stack
      self.stack.append(np.stack(currNode.state))

    ## 5) Check if the node is the goal state
      if np.array_equal(currNode.state, self.goalState):
        print("Goal state found!\n",np.matrix(currNode.state))
        print("number of nodes explored: ", len(self.stack))
        print("The depth of the goal node is: ", currNode.cost)
        print("The most nodes in the frontier during the search was: ", maxNodes)
        return

    ## 6) If not, create the children and add them to the frontier - also add the current node to stack
      neighbors = self.findNeighbors(currNode)

      for i in range(len(neighbors)):
        foundInStack = False
        for j in range(len(self.stack)):
          if (np.array_equal(neighbors[i].state, self.stack[j])):
            foundInStack = True
        if not(foundInStack) :
          frontier.add(neighbors[i])

    ## Loop back
    print("Frontier end found with nothing - No Solution!")
    return


  def solveAStarEuclidean(self):
    frontier = Frontiereuclid()
    start = Node(state=self.startState, parent=None, operator=None, cost=0, misplaced=0, euclideanDistance=0)
    start.euclideanDistanceCost = self.calcEuclidDistance(start)
    maxNodes = 0
     ## 1) Push the node to the frontier (initial start)
    frontier.add(start)
    print("Start of search: size of frontier is", frontier.retLength()) # print the size of the frontier

    ## 2) See if the frontier is empty
    while frontier.retLength() > 0:
      if frontier.retLength() == 0:
        print("Frontier is empty - No Solution!")
        return

    ## 3) Pop off the node from frontier
      if frontier.retLength() > maxNodes:
        maxNodes = frontier.retLength()
      currNode = frontier.popLeastCost()

    ## 4) Check if the node is a repeat - skip it, else add it to the stack
      self.stack.append(np.stack(currNode.state))

    ## 5) Check if the node is the goal state
      if np.array_equal(currNode.state, self.goalState):
        print("Goal state found!\n",np.matrix(currNode.state))
        print("Number of nodes explored: ", len(self.stack))
        print("The depth of the goal node is: ", currNode.cost)
        print("The most nodes in the frontier at once during the search was: ", maxNodes)
        return

    ## 6) If not, create the children and add them to the frontier - also add the current node to stack
      neighbors = self.findNeighbors(currNode)

      for i in range(len(neighbors)):
        foundInStack = False
        for j in range(len(self.stack)):
          if (np.array_equal(neighbors[i].state, self.stack[j])):
            foundInStack = True
        if not(foundInStack) :
          frontier.add(neighbors[i])

    ## Loop back
    print("Frontier end found with nothing - No Solution!")
    return


  def findNeighbors(self, node):
    ## This finds the position of the blank in the matrix, and switches with its neighbors - with a wall check
    #print("DEBUG: now in findNeighbors")
    neighbors = []
    rowPos = -1
    colPos = -1

    ## Find the position of blank (0) in the matrix
    for i in range(0,len(node.state)): # for each row
      for j in range(0,len(node.state[i])): # for each element in the row
        if node.state[i][j] == 0:
          rowPos = i
          colPos = j
    #print(DEBUG: rowPos, colPos)
    if rowPos == -1 or colPos == -1:
      raise Exception("Error - never found blank within the puzzle!")

    ## Now that position of blank (0) is found, check for if walls exists and do operations on possible neighbors
    # Right direction
    if colPos + 1 < len(node.state[rowPos]):
      rightNode = Node(state=np.stack(node.state), parent=node, operator=None, cost=node.cost + 1, misplaced=0,euclideanDistance=0)
      tempVal = rightNode.state[rowPos][colPos+1]
      rightNode.state[rowPos][colPos+1] = 0
      rightNode.state[rowPos][colPos] = tempVal
      rightNode.misplacedCost = self.calcMisplacedTiles(rightNode)
      rightNode.euclideanDistanceCost = self.calcEuclidDistance(rightNode)
      neighbors.append(rightNode)
    # Down direction
    if rowPos + 1 < len(node.state):
      downNode = Node(state=np.stack(node.state), parent=node, operator=None, cost=node.cost + 1,  misplaced=0,euclideanDistance=0)
      tempVal = downNode.state[rowPos+1][colPos]
      downNode.state[rowPos+1][colPos] = 0
      downNode.state[rowPos][colPos] = tempVal
      downNode.misplacedCost = self.calcMisplacedTiles(downNode)
      downNode.euclideanDistanceCost = self.calcEuclidDistance(downNode)
      neighbors.append(downNode)
    # Left position
    if colPos - 1 >= 0:
      leftNode = Node(state=np.stack(node.state), parent=node, operator=None, cost=node.cost + 1,  misplaced=0,euclideanDistance=0)
      tempVal = leftNode.state[rowPos][colPos-1]
      leftNode.state[rowPos][colPos-1] = 0
      leftNode.state[rowPos][colPos] = tempVal
      leftNode.misplacedCost = self.calcMisplacedTiles(leftNode)
      leftNode.euclideanDistanceCost = self.calcEuclidDistance(leftNode)
      neighbors.append(leftNode)
    # Up direction
    if rowPos - 1 >= 0:
      upNode = Node(state=np.stack(node.state), parent=node, operator=None, cost=node.cost + 1, misplaced=0,euclideanDistance=0)
      tempVal = upNode.state[rowPos-1][colPos]
      upNode.state[rowPos-1][colPos] = 0
      upNode.state[rowPos][colPos] = tempVal
      upNode.misplacedCost = self.calcMisplacedTiles(upNode)
      upNode.euclideanDistanceCost = self.calcEuclidDistance(upNode)
      neighbors.append(upNode)
    return neighbors


  def calcMisplacedTiles(self,node):
    tileCount = 0
    for i in range(len(self.goalState)):
      for j in range(len(self.goalState[i])):
        if node.state[i][j] != self.goalState[i][j] and node.state[i][j] != 0:
          tileCount += 1
    return tileCount

  def calcEuclidDistance(self,node):
    misplacedRow = 0
    misplacedColumn = 0
    goalRow = 0
    goalColumn = 0
    Euclid = 0

    ## Compare the misplaced and the correct
    # look from the point of the misplaced node - easier for calculation
    #print("DEBUG: in calc euclid function for",len(node.state),"x",len(node.state[0]))
    """
    for i in range(0,len(node.state)):
      for j in range(0,len(node.state[i])):
        misplacedRow = i
        misplacedColumn = j
        if node.state[i][j] == 0: # edge case for 0, since it needs to be at the bottom right
          goalRow = len(self.goalState) - 1
          goalColumn = goalRow
        else:
          goalRow = math.floor((node.state[i][j] - 1) / len(self.goalState))
          goalColumn = (node.state[i][j] - 1) % len(self.goalState)
        #print(node.state[i][j], "at (", misplacedRow, misplacedColumn, "), should be in (", goalRow, goalColumn, ")")
        diffX = abs(goalRow - misplacedRow)
        diffY = abs(goalColumn - misplacedColumn)
        Euclid += sqrt(diffX**2 + diffY**2)
    """
    for i in range(0,len(node.state)):
      for j in range(0,len(node.state[i])):
        misplacedRow = i
        misplacedColumn = j
        if node.state[i][j] != 0: # edge case for 0, since it needs to be at the bottom right
          goalRow = math.floor((node.state[i][j] - 1) / len(self.goalState))
          goalColumn = (node.state[i][j] - 1) % len(self.goalState)
          #print(node.state[i][j], "at (", misplacedRow, misplacedColumn, "), should be in (", goalRow, goalColumn, ")")
          diffX = abs(goalRow - misplacedRow)
          diffY = abs(goalColumn - misplacedColumn)
          Euclid += sqrt(diffX**2 + diffY**2)
    #print("Euclid =",Euclid)
    return(Euclid)


def goaltest(self,node):
  return np.array_equal(node.state, np.arange(9))


def startUser():
  print("For now, the default selection of an 8 puzzle will be used.")
  return([[1,2,3],[4,8,0],[7,6,5]])


print("Welcome to ___ 8 puzzle solver!\n") #change to IDS?
response = input("Type \"1\" to use a default puzzle, or \"2\" to enter your own puzzle.\n")
while((response != '1') and (response != '2')):
    response = input("Invalid input. Type \"1\" to use a default puzzle, or \"2\" to enter your own puzzle.\n")

def dupcheck(x):
  #print("Checking for duplicates within row")
  for elem in x:
    if x.count(elem) > 1:
      return True
  return False

def checkMatrixForDuplicates(x):
  #print("Checking for Duplicates between rows")
  mergedGrid = x[0] + x[1] + x[2]
  #print("Display inputted values")
  #print(mergedGrid)
  if dupcheck(mergedGrid) == True :
    return True
  return False

def checkInputsAreNumbers(x):
  #print("Checking input contains numbers")
  for elem in x:
    if(elem.isdigit() == False):
      return False
  return True

def inputCustomGrid():
  first_row = input("Enter the first row, use spaces or tabs between unique numbers: ").split()
  while((len(first_row) != 3) or (checkInputsAreNumbers(first_row) == False) or (dupcheck(first_row) == True)) :
    first_row = input("Invalid input. Enter three single-digit unique numbers separated by spaces or tabs: ").split()
  second_row = input("Enter the second row, use spaces or tabs between unique numbers: ").split()
  while((len(second_row) != 3) or (checkInputsAreNumbers(second_row) == False) or (dupcheck(second_row) == True)) :
    second_row = input("Invalid input. Enter three single-digit unique numbers separated by spaces or tabs: ").split()
  third_row = input("Enter the third row, use spaces or tabs between unique numbers: ").split()
  while((len(third_row) != 3) or (checkInputsAreNumbers(third_row) == False) or (dupcheck(third_row) == True)) :
    third_row = input("Invalid input. Enter three single-digit unique numbers separated by spaces or tabs: ").split()
  grid = [first_row, second_row, third_row]
  return(grid)

if(response == '1') :
  solution = Problem(startUser(),["None","Up","Down","Left","Right"])
elif(response == '2'):
  print("Enter your puzzle, use a zero to represent the blank")
  newGrid = inputCustomGrid()
  while(checkMatrixForDuplicates(newGrid) == True):
    print("Puzzle contains duplicates. Please try again.")
    newGrid = inputCustomGrid()
  for x in newGrid:
    for i in range(0, len(x)):
      x[i] = int(x[i])
  print(newGrid)
  solution = Problem(newGrid,["None","Up","Down","Left","Right"])

print("Enter your choice of algorithm (1-3)\n")
print("1) Uniform Cost Search\n")
print("2) A* with the Misplaced Tile heuristic.\n")
print("3) A* with the Euclidean distance heuristic.\n")
algChoice = input()
while((algChoice.isdigit() == False) or (int(algChoice) < 1) or (int(algChoice) > 3)):
  algChoice = input("Invalid input. Choose an algorithm using a number between 1 and 3.")

if algChoice == '1':
  starttime = time.time()
  solution.solveUniformCostSearch()
  print("Time required to solve Uniform Cost Search is:", (time.time() - starttime))
elif algChoice == '2':
  starttime = time.time()
  solution.solveAStarMisplaced()
  print("Time required to solve AStar Misplaced is:", (time.time() - starttime))
elif algChoice == '3':
  starttime = time.time()
  solution.solveAStarEuclidean()
  print("Time required to solve AStar Euclidean is:", (time.time() - starttime))

